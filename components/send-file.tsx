import { FilePond } from 'react-filepond';

import 'filepond/dist/filepond.min.css';
import axios from 'axios';
import config from '../env-config';
import { postingsListStore } from '../stores/postings-list';
import { withAuth } from '../services/with-auth';
import { useEffect } from 'react';
import { loginStore } from '../stores/user-profile';

const { backendAddress } = config;

// File sending architecture as follows:
// 1) Request signed fields from backend
// 2) Send file directly from browser to S3 with help of signed fields providing access
// 3) Finalize with another request to backend when finished transmission
// This removes backend from file transfer chain

export default function SendFile() {
  const loadData = postingsListStore(state => state.loadLatest);
  const authToken = loginStore(state => state.token);

  const finalize = (s3Key: string): Promise<void> => {
    return new Promise((resolve, reject) => {
      const socket = new WebSocket('ws://localhost:3001/');
      socket.onopen = () => {
        const eventName = 'image-processing';
        const initMessage = {
          event: eventName,
          data: { authToken, s3Key },
        };
        socket.onmessage = (event) => {
          const { data } = JSON.parse(event.data);
          if (data.isSuccess) {
            resolve();
          } else {
            reject();
          }
        };
        socket.send(JSON.stringify(initMessage));
      };
    });
  };

  // Long list of params is dictated by FilePond 3rd party component
  // Cannot be async by design
  const processFile = (fieldName, file, metadata, load, error, progress, abort) => {
    // Request object for direct file transfer to S3
    const request = new XMLHttpRequest();
    request.open('POST', 'http://127.0.0.1:9000/image-uploads');

    // Update progress
    request.upload.onprogress = (e) => {
      progress(e.lengthComputable, e.loaded, e.total);
    }

    // File is sent along with extra data from S3
    const requestData = new FormData();
    requestData.append('file', file);
    // S3 reads Content-Type from POST form field instead of header -- dictated by S3 design
    requestData.append('Content-Type', file.type);

    // Request secret S3 signed fields from backend first
    withAuth(axios).get(`${backendAddress}/image-uploads/get-image-upload-fields/`)
      .then(({ data: imageUploadFields }) => {
        // Populate request data for sending with signed fields
        Object.keys(imageUploadFields).forEach(key => {
          requestData.append(key, imageUploadFields[key]);
        });
        // S3Key is generated by backend
        const s3Key =  imageUploadFields['key'];

        // On request end
        request.onload = () => {
          if (request.status >= 200 && request.status < 300) {
            // Finalize image sending with another request to backend
            finalize(s3Key)
              .then(() => {
                load();
                loadData(); // update list on page
              })
              .catch(() => {
                error();
              });
          } else {
            error();
          }
        }

        // Check that user didn't press abort button before we got signed fields from backend
        if (!request['wasAborted']) {
          request.send(requestData);
        }
      })
      .catch(() => {
        error();
      });

    // We must return this object and not promise hence no async
    return {
      abort: () => {
        request['wasAborted'] = true; // If request wasn't started then don't let it start
        request.abort(); // Abort possibly started request
        abort();
      }
    }
  };

  useEffect(() => {
    const socket = new WebSocket('ws://localhost:3001/');
    socket.onopen = () => {
      console.log(123456);
      socket.send('{ "event": "image-processing", "data": { "some": 17 } }');
    };
    // socket.send('{ event: "image-processing", data: 17 }');
    // socket.onopen(() => {
    //
    // });
    // socket.addEventListener('image-processing', function (event) {
    //   console.log(event);
    //   socket.send({
    //     authToken: token,
    //   });
    // });
  }, []);

  return (
    <div className="form">
      <FilePond allowMultiple={false} server={{ process: processFile }} />
    </div>
  );
}
